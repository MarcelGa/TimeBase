"""gRPC server implementation for TimeBase providers."""

import asyncio
import logging
from concurrent import futures
from typing import Optional
import grpc
from datetime import datetime

from .provider_base import TimeBaseProvider
from .models import StreamControl, HealthStatus, ProviderCapabilitiesResponse

# Import generated protobuf classes (these will be generated by protoc)
try:
    from .generated import provider_pb2, provider_pb2_grpc
except ImportError:
    # Fallback for when protobuf files haven't been generated yet
    provider_pb2 = None
    provider_pb2_grpc = None


class DataProviderServicer(provider_pb2_grpc.DataProviderServicer if provider_pb2_grpc else object):
    """gRPC servicer for TimeBase provider protocol."""

    def __init__(self, provider: TimeBaseProvider):
        self.provider = provider
        self.logger = provider.logger

    async def GetCapabilities(self, request, context):
        """Get provider capabilities."""
        try:
            caps = await self.provider.get_capabilities()

            # Convert to protobuf message
            capabilities = provider_pb2.ProviderCapabilities(
                name=caps["name"],
                version=caps["version"],
                slug=caps["slug"],
                supports_historical=caps["supports_historical"],
                supports_realtime=caps["supports_realtime"],
                supports_backfill=caps.get("supports_backfill", False),
                data_types=caps["data_types"],
                intervals=caps["intervals"],
                rate_limits=provider_pb2.RateLimits(
                    requests_per_minute=caps["rate_limits"]["requests_per_minute"],
                    requests_per_day=caps["rate_limits"]["requests_per_day"]
                )
            )

            if "max_lookback_days" in caps:
                capabilities.max_lookback_days = caps["max_lookback_days"]

            return capabilities

        except Exception as e:
            self.logger.error(f"Error getting capabilities: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))
            return provider_pb2.ProviderCapabilities()

    async def GetHistoricalData(self, request, context):
        """Stream historical data."""
        try:
            start_time = request.start_time.ToDatetime()
            end_time = request.end_time.ToDatetime()

            async for data_point in self.provider.get_historical_data(
                symbol=request.symbol,
                interval=request.interval,
                start_time=start_time,
                end_time=end_time,
                limit=request.limit if request.HasField("limit") else None
            ):
                # Convert to protobuf message
                timestamp = provider_pb2.Timestamp()
                timestamp.FromDatetime(data_point["timestamp"])

                time_series_data = provider_pb2.TimeSeriesData(
                    symbol=data_point["symbol"],
                    timestamp=timestamp,
                    open=data_point["open"],
                    high=data_point["high"],
                    low=data_point["low"],
                    close=data_point["close"],
                    volume=data_point["volume"],
                    interval=data_point["interval"],
                    provider=data_point["provider"]
                )

                # Add metadata if present
                if "metadata" in data_point and data_point["metadata"]:
                    for key, value in data_point["metadata"].items():
                        time_series_data.metadata[key] = str(value)

                yield time_series_data

        except NotImplementedError:
            context.set_code(grpc.StatusCode.UNIMPLEMENTED)
            context.set_details("Historical data not supported")
        except Exception as e:
            self.logger.error(f"Error streaming historical data: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))

    async def StreamRealTimeData(self, request_iterator, context):
        """Stream real-time data with bidirectional control."""
        try:
            # Convert protobuf stream to async iterator of dicts
            async def subscription_stream():
                async for control_msg in request_iterator:
                    yield {
                        "action": control_msg.action,
                        "symbol": control_msg.symbol,
                        "interval": control_msg.interval,
                        "options": dict(control_msg.options) if control_msg.options else {}
                    }

            async for data_point in self.provider.stream_realtime_data(subscription_stream()):
                # Convert to protobuf message (same as historical)
                timestamp = provider_pb2.Timestamp()
                timestamp.FromDatetime(data_point["timestamp"])

                time_series_data = provider_pb2.TimeSeriesData(
                    symbol=data_point["symbol"],
                    timestamp=timestamp,
                    open=data_point["open"],
                    high=data_point["high"],
                    low=data_point["low"],
                    close=data_point["close"],
                    volume=data_point["volume"],
                    interval=data_point["interval"],
                    provider=data_point["provider"]
                )

                # Add metadata if present
                if "metadata" in data_point and data_point["metadata"]:
                    for key, value in data_point["metadata"].items():
                        time_series_data.metadata[key] = str(value)

                yield time_series_data

        except NotImplementedError:
            context.set_code(grpc.StatusCode.UNIMPLEMENTED)
            context.set_details("Real-time streaming not supported")
        except Exception as e:
            self.logger.error(f"Error in real-time streaming: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))

    async def HealthCheck(self, request, context):
        """Health check endpoint."""
        try:
            health = await self.provider.health_check()

            # Convert to protobuf message
            timestamp = provider_pb2.Timestamp()
            timestamp.FromDatetime(health["timestamp"])

            health_status = provider_pb2.HealthStatus(
                status=health["status"],
                message=health["message"],
                timestamp=timestamp
            )

            # Add metrics if present
            if "metrics" in health and health["metrics"]:
                for key, value in health["metrics"].items():
                    health_status.metrics[key] = str(value)

            return health_status

        except Exception as e:
            self.logger.error(f"Error in health check: {e}")
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(str(e))

            # Return unhealthy status
            timestamp = provider_pb2.Timestamp()
            timestamp.FromDatetime(datetime.utcnow())

            return provider_pb2.HealthStatus(
                status="UNHEALTHY",
                message=str(e),
                timestamp=timestamp
            )


class TimeBaseGrpcServer:
    """gRPC server for TimeBase providers."""

    def __init__(self, provider: TimeBaseProvider, port: int = 50051, host: str = "0.0.0.0"):
        self.provider = provider
        self.port = port
        self.host = host
        self.server = None
        self.logger = provider.logger

    async def start(self):
        """Start the gRPC server."""
        if provider_pb2_grpc is None:
            raise RuntimeError(
                "Protobuf files not generated. Run 'python -m grpc_tools.protoc' "
                "to generate the required files."
            )

        # Create server
        self.server = grpc.aio.server(
            futures.ThreadPoolExecutor(max_workers=10),
            options=[
                ('grpc.max_send_message_length', 50 * 1024 * 1024),  # 50MB
                ('grpc.max_receive_message_length', 50 * 1024 * 1024),  # 50MB
            ]
        )

        # Add servicer
        servicer = DataProviderServicer(self.provider)
        provider_pb2_grpc.add_DataProviderServicer_to_server(servicer, self.server)

        # Add reflection for debugging
        from grpc_reflection.v1alpha import reflection
        service_names = (
            provider_pb2.DESCRIPTOR.services_by_name['DataProvider'].full_name,
            reflection.SERVICE_NAME,
        )
        reflection.enable_server_reflection(service_names, self.server)

        # Bind to address
        address = f"{self.host}:{self.port}"
        self.server.add_insecure_port(address)

        # Start server
        await self.server.start()
        self.logger.info(f"gRPC server started on {address}")

        # Setup provider
        try:
            await self.provider.setup()
        except Exception as e:
            self.logger.warning(f"Provider setup failed: {e}")

    async def stop(self):
        """Stop the gRPC server."""
        if self.server:
            self.logger.info("Stopping gRPC server...")

            # Cleanup provider
            try:
                await self.provider.cleanup()
            except Exception as e:
                self.logger.warning(f"Provider cleanup failed: {e}")

            await self.server.stop(grace=5.0)
            await self.server.wait_for_termination()
            self.logger.info("gRPC server stopped")

    async def wait_for_termination(self):
        """Wait for server termination."""
        if self.server:
            await self.server.wait_for_termination()


def run_grpc_server(provider: TimeBaseProvider, port: int = 50051, host: str = "0.0.0.0"):
    """Run the gRPC server for a TimeBase provider.

    This is a convenience function that creates and runs a gRPC server.
    It handles graceful shutdown on SIGINT/SIGTERM.

    Args:
        provider: The TimeBase provider instance
        port: Port to bind to (default: 50051)
        host: Host to bind to (default: "0.0.0.0")
    """
    async def main():
        server = TimeBaseGrpcServer(provider, port, host)

        def signal_handler(signum, frame):
            server.logger.info(f"Received signal {signum}, shutting down...")
            asyncio.create_task(server.stop())

        import signal
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        try:
            await server.start()
            await server.wait_for_termination()
        except KeyboardInterrupt:
            pass
        finally:
            await server.stop()

    # Run the async main function
    asyncio.run(main())